const crypto = require('crypto');
const OAuth = require('oauth-1.0a');

function hash(baseString, key) {
  return crypto
    .createHmac('sha256', key)
    .update(baseString)
    .digest('base64');
}

class NetSuiteTBAuth extends OAuth {
  constructor(options) {
    const baseOptions = {
      hash_function: hash,
      signature_method: 'HMAC-SHA256',
      nonce_length: 20,
    };
    super({ ...baseOptions, ...options });
  }

  percentEncodeArrayValues(arrParam) {
    // mutate values of the array
    const arr = arrParam;
    arr.forEach((value, i) => {
      arr[i] = this.percentEncode(value);
    });
    return arr;
  }

  toBaseStringArray(oAuthData) {
    return [
      this.realm,
      oAuthData.oauth_consumer_key,
      oAuthData.oauth_token,
      oAuthData.oauth_nonce,
      oAuthData.oauth_timestamp,
    ];
  }

  getBaseString(request, oAuthData) {
    const values = this.toBaseStringArray(oAuthData);
    this.percentEncodeArrayValues(values);
    return values.join('&');
  }

  toNode(oAuthData) {
    const account = this.realm;
    return {
      name: 'platformMsgs:tokenPassport',
      attributes: {
        'soap:mustUnderstand': '0',
        'soap:actor': 'http://schemas.xmlsoap.org/soap/actor/next',
      },
      children: [
        {
          name: 'platformMsgs:account',
          value: account,
        },
        {
          name: 'platformMsgs:consumerKey',
          value: oAuthData.oauth_consumer_key,
        },
        {
          name: 'platformMsgs:token',
          value: oAuthData.oauth_token,
        },
        {
          name: 'platformMsgs:nonce',
          value: oAuthData.oauth_nonce,
        },
        {
          name: 'platformMsgs:timestamp',
          value: String(oAuthData.oauth_timestamp),
        },
        {
          name: 'platformMsgs:signature',
          attributes: {
            algorithm: 'HMAC_SHA256',
          },
          value: oAuthData.oauth_signature,
        },
      ],
    };
  }
}

module.exports = NetSuiteTBAuth;
