/* eslint-disable class-methods-use-this */
/* eslint-disable no-await-in-loop */
const debug = require('debug')('netsuite-client');
const path = require('path');
const fs = require('fs');
const util = require('util');
const soap = require('./soap');
const foldersUtils = require('./folders');
const { NetSuiteSalesOrder } = require('./netsuite-sales-order');
const { NetSuitePurchaseOrder, netSuitePurchaseOrderStatus } = require('./netsuite-purchase-order');
const NetSuiteItemFulfillment = require('./netsuite-item-fulfillment');
const NetSuiteCashSale = require('./netsuite-cash-sale');

// ----- Custom Type Definitions

/**
 * NetSuiteClient configuration object
 * @typedef NetSuiteClientConfig
 * @type {object}
 * @property {string} [Config.version]              version of the SuiteTalk SOAP api
 * @property {string} [Config.domain]               api endpoint: <netsuite-account-id>.suitetalk.api.netsuite.com
 * @property {object} Config.passport
 * @property {string} Config.passport.account       NetSuite account id
 * @property {object} Config.oauth
 * @property {object} Config.oauth.consumer
 * @property {string} Config.oauth.consumer.key     NetSuite integration consumer key
 * @property {string} Config.oauth.consumer.secret  NetSuite integration consumer secret
 * @property {object} Config.oauth.token
 * @property {string} Config.oauth.token.key        NetSuite access token key
 * @property {string} Config.oauth.token.secret     NetSuite access token secret
 * @property {number} [Config.maxRetries]           NetSuite webservice max retries
 * @property {number} [Config.pauseDuration]        Duration between NetSuite webservice retries
 * @property {number} [Config.pageSize]             Number of records returned per paged
 * @property {boolean} [Config.bodyFieldsOnly]      Only return fields associated with record type
 */

/**
 * @typedef UpdateValues
 * @type {object}
 * @property {string}                   UpdateValues.name               the field name to update
 * @property {string|number|boolean|{}} UpdateValues.value              value to update
 * @property {string}                   [UpdateValues.customFieldType]  OPTIONAL required for NetSuite custom fields
 */

/**
 * @private  This variable is for internal use only
 * @constant
 * @type {number}
 * @default
 */
const DEFAULT_NETSUITE_WEBSERVICE_MAX_RETRIES = 5;

/**
 * @private  This variable is for internal use only
 * @constant
 * @type {number}
 * @default
 */
const DEFAULT_DURATION_BETWEEN_NETSUITE_WEBSERVICE_RETRIES = 5000; // 5 seconds

/**
 * @private  This variable is for internal use only
 * @constant
 * @type {number}
 * @default
 */
const DEFAULT_NETSUITE_SEARCH_PAGE_SIZE = 1000;

/**
 * @private  This variable is for internal use only
 * @constant
 * @type {boolean}
 * @default
 */
const DEFAULT_NETSUITE_RETURN_BODY_FIELDS_ONLY = true;

/**
 * @private This variable is for internal use only
 * @constant
 * @type {number}
 * @default
 */

const DEFAULT_NETSUITE_CONCURRENCY = 5;

// https://webservices.netsuite.com/wsdl/v2020_1_0/netsuite.wsdl
/**
 * @private  This variable is for internal use only
 * @constant
 * @type {number}
 * @default
 */
const DEFAULT_VERSION = '2020_1';

/**
 * @private
 * @constant DEFAULT_CONFIG
 * @type {NetSuiteClientConfig}
 * @default
 */
const DEFAULT_CONFIG = {
  concurrency: DEFAULT_NETSUITE_CONCURRENCY,
  version: DEFAULT_VERSION,
  domain: '',
  passport: { account: '' },
  oauth: {
    consumer: { key: '', secret: '' },
    token: { key: '', secret: '' },
  },
  maxRetries: DEFAULT_NETSUITE_WEBSERVICE_MAX_RETRIES,
  pauseDuration: DEFAULT_DURATION_BETWEEN_NETSUITE_WEBSERVICE_RETRIES,
  pageSize: DEFAULT_NETSUITE_SEARCH_PAGE_SIZE,
  bodyFieldsOnly: DEFAULT_NETSUITE_RETURN_BODY_FIELDS_ONLY,
};

const readFile = util.promisify(fs.readFile);

// ----- NetSuiteClient class

/**
 * NetSuiteClient class
 */
class NetSuiteClient {
  /**
   * Create an instance of the NetSuiteClient class
   * @param {NetSuiteClientConfig} netsuiteClientConfig  NetSuiteClient configuration object
   */
  constructor(netsuiteClientConfig) {
    // this.config = { ...defaultConfig, ...netsuiteClientConfig };
    this.config = NetSuiteClient.setConfig(DEFAULT_CONFIG, netsuiteClientConfig);
  }

  /**
   * @private
   * @static
   * @param  {Array<string>} source
   * @param  {Object} config
   */
  static validateFields(source, config) {
    source.forEach(field => {
      if (!(field in config)) {
        throw new Error('Invalid NetSuite Client Config');
      }
    });
  }

  /**
   * @private This method is for internal use only
   * @static
   * @param  {object} defaultConfig the default config
   * @param  {object} clientConfig  config provided by the client
   * @return {NetSuiteClientConfig}
   */
  static setConfig(defaultConfig, clientConfig) {
    const requiredFields = ['domain', 'passport', 'oauth'];
    const requiredPassportFields = ['account'];
    const requiredOauthFields = ['consumer', 'token'];
    const requiredKeySecretFields = ['key', 'secret'];
    if (!Object.keys(clientConfig).length) {
      throw new Error('Invalid Netsuite Client Config');
    }
    NetSuiteClient.validateFields(requiredFields, clientConfig);
    NetSuiteClient.validateFields(requiredPassportFields, clientConfig.passport);
    NetSuiteClient.validateFields(requiredOauthFields, clientConfig.oauth);
    NetSuiteClient.validateFields(requiredKeySecretFields, clientConfig.oauth.consumer);
    NetSuiteClient.validateFields(requiredKeySecretFields, clientConfig.oauth.token);
    const overrideFields = ['concurrency', 'version', 'maxRetries', 'pauseDuration', 'pageSize', 'bodyFieldsOnly'];
    const config = clientConfig;
    overrideFields.forEach(field => {
      if (!(field in config) || config[field] === undefined || config[field] === null || config[field] === '') {
        config[field] = defaultConfig[field];
      }
    });
    return config;
  }
  // ----- Error Handling

  /**
   * Check the error object to see if we've exceeded NetSuite's concurrent request limit
   * @private  This method is for internal use only
   * @static
   * @param {object} err  Error object
   * @return {boolean}  Returns true if exceeded NetSuite's concurrent request limit
   */
  static exceededConcurrentRequestLimit(err) {
    return (
      err &&
      err.detail &&
      err.detail.exceededConcurrentRequestLimitFault &&
      err.detail.exceededConcurrentRequestLimitFault.code &&
      err.detail.exceededConcurrentRequestLimitFault.code === 'WS_REQUEST_BLOCKED'
    );
  }

  /**
   * @private  This method is for internal use only
   */
  static checkStatusSuccess(status) {
    if (status && status['@isSuccess'] && status['@isSuccess'] !== 'true') {
      const error = new Error('Unsuccessful response from NetSuite');
      const detail = status.statusDetail;
      if (detail) {
        error.message = detail.message;
        error.code = detail.code;
      }
      throw error;
    }
  }

  // ----- Helper properties and  methods

  /**
   * @private  This method is for internal use only
   */
  async pause() {
    return new Promise(resolve => {
      // const startTime = Date.now();
      function timeoutCompleted() {
        // const elapsedTime = Date.now() - startTime;
        // console.log(`Waited ${Math.floor(elapsedTime / 1000)} seconds`);
        resolve();
      }
      setTimeout(timeoutCompleted, this.config.pauseDuration);
    });
  }

  /**
   * @private  This property is for internal use only
   */
  get maxRetries() {
    return this.config.maxRetries;
  }

  /**
   * @private  This method is for internal use only
   */
  static async readFileContent(filePath) {
    const file = await readFile(filePath);
    return file.toString('base64');
  }

  /**
   * @private  This method is for internal use only
   */
  async makeSoapRequest(operation, body) {
    let numRetries = 0;
    while (numRetries <= this.maxRetries) {
      try {
        debug('Making soap request - ', operation, 'using body:', body);
        const response = await soap({ config: this.config, operation, body });
        return response;
      } catch (err) {
        if (NetSuiteClient.exceededConcurrentRequestLimit(err)) {
          await this.pause();
          numRetries += 1;
          debug(`NetSuite webservice retry: ${numRetries}`);
        } else {
          throw new Error(err);
        }
      }
    }
    throw new Error('Exceeded webservice max retries.');
  }

  /**
   * Get a single record
   * @private  This method is for internal use only
   */
  async getRecord({ type, internalId, externalId }) {
    const body = NetSuiteClient.buildRecordBody({
      type,
      internalId,
      externalId,
    });
    const response = await this.makeSoapRequest('get', body);
    const { status, record } = response || {};
    NetSuiteClient.checkStatusSuccess(status);
    return record;
  }

  /**
   * Update a NetSuite internal record
   * @private  This method is for internal use only
   * @param {object}         props
   * @param {string}         props.type                 NetSuite record type
   * @param {string}         props.internalId           NetSuite internal Id
   * @param {string}         props.externalId           NetSuite external Id
   * @param {UpdateValues[]} props.updateValues         Values to be updated
   * @param {string[]}       props.nullFields           Values to be cleared
   * @param {string}         props.fieldDefinitionType  NetSuite Field Record type
   * @return {boolean}  Returns true if the operation succeeds
   */
  async updateRecord({ type, internalId, externalId, updateValues, nullFields, fieldDefinitionType }) {
    const body = this.buildUpdateBody({ type, internalId, externalId, updateValues, nullFields, fieldDefinitionType });
    debug('Update body object: %O', body);
    const response = await this.makeSoapRequest('update', body);
    debug('Update call response: %O', response);
    NetSuiteClient.checkStatusSuccess(response.status);
    return true;
  }

  // ---- Methods for getting NetSuite-specific Body Formats for SOAP Requests

  /**
   * @private  This method is for internal use only
   */
  buildUrnCore() {
    return `urn:core_${this.config.version}.platform.webservices.netsuite.com`;
  }

  /**
   * @private  This method is for internal use only
   */
  buildUrnCommon() {
    return `urn:common_${this.config.version}.platform.webservices.netsuite.com`;
  }

  /**
   * @private  This method is for internal use only
   */
  buildUrnFileCabinet() {
    return `urn:filecabinet_${this.config.version}.documents.webservices.netsuite.com`;
  }

  /*
  buildUrnSales() {
    return `urn:sales_${this.config.version}.transactions.webservices.netsuite.com`;
  }
  */

  /**
   * @private  This method is for internal use only
   */
  static buildRecordBody({ type, internalId, externalId }) {
    return {
      name: 'platformMsgs:recordRef',
      attributes: {
        'xsi:type': 'platformCore:RecordRef',
        type,
        internalId,
        externalId,
      },
    };
  }

  /**
   * Build a SOAP body for updating a NetSuite internal record
   * @private  This method is for internal use only
   * @param {object}         props
   * @param {string}         props.type                 NetSuite record type
   * @param {string}         props.internalId           NetSuite internal Id
   * @param {string}         props.externalId           NetSuite external Id
   * @param {UpdateValues[]} props.updateValues         Values to be updated
   * @param {string[]}       props.nullFields           Values to be cleared
   * @param {string}         props.fieldDefinitionType  NetSuite field record type
   * @return {object}  Returns an object representing the SOAP body
   */
  buildUpdateBody({ type, internalId, externalId, updateValues = [], nullFields = [], fieldDefinitionType }) {
    const wrapData = {
      name: 'platformMsgs:record',
      attributes: {
        'xsi:type': `${fieldDefinitionType}:${type}`,
      },
      children: [],
    };

    // don't want to set them if we have no value as that would clear the external id
    // with a blank
    if (internalId) wrapData.attributes.internalId = internalId;
    if (externalId) wrapData.attributes.externalId = externalId;

    const defaultFields = [];
    const customFields = [];
    updateValues.forEach(data => {
      if (data.customFieldType) {
        customFields.push(data);
      } else {
        defaultFields.push(data);
      }
    });
    defaultFields.forEach(data => {
      const { name, value, attributes, children, recordRef } = data;
      const fieldName = `${fieldDefinitionType}:${name}`;
      if (recordRef) {
        const { internalId: refIntId, externalId: refExtId } = recordRef || {};
        const ref = {
          name: fieldName,
          attributes: {
            'xmlns:platformCore': this.buildUrnCore(),
            'xsi:type': 'platformCore:RecordRef',
          },
        };
        if (refIntId) ref.attributes.internalId = refIntId;
        if (refExtId) ref.attributes.externalId = refExtId;
        wrapData.children.push(ref);
      } else {
        wrapData.children.push({ name: fieldName, value, attributes, children });
      }
    });
    if (nullFields.length) {
      const nullWrap = {
        name: `platformCore:nullFieldList`,
        attributes: {
          'xmlns:platformCore': this.buildUrnCore(),
        },
        children: nullFields.map(field => ({ name: 'name', value: field })),
      };
      wrapData.children.push(nullWrap);
    }
    if (customFields.length) {
      const customWrap = {
        name: `${fieldDefinitionType}:customFieldList`,
        attributes: {
          'xmlns:platformCore': this.buildUrnCore(),
        },
        children: [],
      };
      customFields.forEach(field => {
        const { name, value, customFieldType } = field;
        const fieldWrap = {
          name: 'platformCore:customField',
          attributes: {
            'xsi:type': `platformCore:${customFieldType}`,
            scriptId: name,
          },
          children: [
            {
              name: 'platformCore:value',
              value,
            },
          ],
        };
        customWrap.children.push(fieldWrap);
      });
      wrapData.children.push(customWrap);
    }
    return wrapData;
  }

  /**
   * @private  This method is for internal use only
   */
  static buildUploadExternalId(filename, folderInternalId) {
    const now = new Date().getTime();
    return `${filename}_${folderInternalId}_${now}`;
  }

  /**
   * @private  This method is for internal use only
   */
  buildUploadBody({ filename, fileContent, folderInternalId }) {
    // Based on https://gitlab.com/twec/digital/netsuite-upload-utils/blob/master/src/file-cabinet-client.ts#L295
    return {
      name: 'platformMsgs:recordRef',
      attributes: {
        'xmlns:q1': this.buildUrnFileCabinet(),
        'xsi:type': 'q1:File',
        internalId: '',
        externalId: NetSuiteClient.buildUploadExternalId(filename, folderInternalId),
      },
      children: [
        { name: 'q1:name', value: filename },
        { name: 'q1:content', value: fileContent },
        {
          name: 'q1:folder',
          attributes: {
            internalId: folderInternalId,
            type: 'folder',
          },
        },
      ],
    };
  }

  /**
   * @private  This method is for internal use only
   */
  buildSearchFolderBody() {
    // Originally based on https://gitlab.com/twec/digital/netsuite-upload-utils/blob/master/src/file-cabinet-client.ts#L354
    return {
      name: 'platformMsgs:search',
      attributes: {
        xmlns: this.buildUrnFileCabinet(),
        'xsi:type': 'FolderSearch',
        // FolderSearch - http://www.netsuite.com/help/helpcenter/en_US/srbrowser/Browser2018_1/schema/search/foldersearch.html?mode=package
      },
    };
  }

  buildDropshipperOrderIdCustomFieldBodyItem(dropshipperOrderId) {
    const operator = !dropshipperOrderId ? 'empty' : 'is';
    return {
      name: 'ns2:customField',
      attributes: {
        operator,
        'xsi:type': 'ns2:SearchStringCustomField',
        scriptId: 'custbody_dropshipper_order_id',
      },
      children: [
        {
          name: 'ns2:searchValue',
          value: dropshipperOrderId,
        },
      ],
    };
  }

  buildNeedsSyncCustomFieldBodyItem(needsSync) {
    return {
      name: 'ns2:customField',
      attributes: {
        'xsi:type': 'ns2:SearchBooleanCustomField',
        scriptId: 'custbody_needsync',
      },
      children: [
        {
          name: 'ns2:searchValue',
          value: needsSync.toString(),
        },
      ],
    };
  }

  buildCustomFieldListContainerBodyItem() {
    return {
      name: 'ns1:customFieldList',
      attributes: {
        'xmlns:ns2': this.buildUrnCore(),
      },
      children: [],
    };
  }

  buildVendorLocationBodyItem(vendorLocation) {
    return {
      name: 'ns1:location',
      attributes: {
        operator: 'anyOf',
        'xsi:type': 'ns2:SearchMultiSelectField',
        'xmlns:ns2': this.buildUrnCore(),
      },
      children: [
        {
          name: 'ns2:searchValue',
          attributes: {
            internalId: vendorLocation,
            'xsi:type': 'ns2:RecordRef',
          },
        },
      ],
    };
  }

  buildVendorIdBodyItem(vendorId) {
    return {
      name: 'ns1:entity',
      attributes: {
        operator: 'anyOf',
        'xsi:type': 'ns2:SearchMultiSelectField',
        'xmlns:ns2': this.buildUrnCore(),
      },
      children: [
        {
          name: 'ns2:searchValue',
          attributes: {
            internalId: vendorId,
            'xsi:type': 'ns2:RecordRef',
          },
        },
      ],
    };
  }

  /**
   * @private  This method is for internal use only
   */
  buildStatusBodyItem(status) {
    return {
      name: 'ns1:status',
      attributes: {
        operator: 'anyOf',
        'xsi:type': 'ns2:SearchEnumMultiSelectField',
        'xmlns:ns2': this.buildUrnCore(),
      },
      children: [
        {
          name: 'ns2:searchValue',
          value: status,
          attributes: {
            'xsi:type': 'xsd:string',
          },
        },
      ],
    };
  }

  /**
   * @private  This method is for internal use only
   */
  buildTransactionDateRangeBodyItem({ fromDate, toDate }) {
    return {
      name: 'ns1:tranDate',
      attributes: {
        operator: 'within',
        'xsi:type': 'ns2:SearchDateField',
        'xmlns:ns2': this.buildUrnCore(),
      },
      children: [
        {
          name: 'ns2:searchValue',
          value: fromDate.toISOString(),
          attributes: {
            'xsi:type': 'xsd:dateTime',
          },
        },
        {
          name: 'ns2:searchValue2',
          value: toDate.toISOString(),
          attributes: {
            'xsi:type': 'xsd:dateTime',
          },
        },
      ],
    };
  }

  /**
   * @private  This method is for internal use only
   */
  buildCreatedFromBodyItem(internalId) {
    return {
      name: 'ns1:createdFrom',
      attributes: {
        operator: 'anyOf',
        'xsi:type': 'ns2:SearchMultiSelectField',
        'xmlns:ns2': this.buildUrnCore(),
      },
      children: [
        {
          name: 'ns2:searchValue',
          attributes: {
            internalId,
            'xsi:type': 'ns2:RecordRef',
          },
        },
      ],
    };
  }

  /**
   * @private  This method is for internal use only
   */
  buildRecordTypeBodyItem(recordType) {
    return {
      name: 'ns1:type',
      attributes: {
        operator: 'anyOf',
        'xsi:type': 'ns2:SearchEnumMultiSelectField',
        'xmlns:ns2': this.buildUrnCore(),
      },
      children: [
        {
          name: 'ns2:searchValue',
          value: recordType,
          attributes: {
            'xsi:type': 'xsd:string',
          },
        },
      ],
    };
  }

  /**
   * @private  This method is for internal use only
   */
  buildSearchBodyContainer() {
    return {
      name: 'searchRecord',
      attributes: {
        'xsi:type': 'ns1:TransactionSearchBasic',
        'xmlns:ns1': this.buildUrnCommon(),
      },
      children: [],
    };
  }

  // This was a test to see if we could get the Advanced Searching working. The NetSuite server is sending
  // back multiple copies of each record, resulting in many more records being returned. Sometimes it sends
  // back 2 copies, other times 5 copies. Was unable to figure out why this is happening so deciding not to use this.
  /*
  buildAdvancedSearchBody({ 
    recordType,
    fromDate,
    toDate,
    status,
    vendorId,
    dropshipperOrderId,
    needsSync,
  }) {
    return {
      name: 'searchRecord',
      attributes: {
        'xsi:type': 'ns1:TransactionSearchAdvanced',
        'xmlns:ns1': this.buildUrnSales(),
      },
      children: [
        {
          name: 'ns1:criteria',
          children: [
            {
              name: 'ns1:basic',
              children: [
                {
                  name: 'ns1:type',
                  attributes: {
                    operator: 'anyOf',
                    'xmlns:ns1': this.buildUrnCommon(),
                  },
                  children: [
                    {
                      name: 'ns1:searchValue',
                      value: recordType,
                      attributes: {
                        'xsi:type': 'xsd:string',
                        'xmlns:ns1': this.buildUrnCore(),
                      },
                    },
                  ],
                },
                {
                  name: 'ns1:tranDate',
                  attributes: {
                    operator: 'within',
                    'xmlns:ns1': this.buildUrnCommon(),
                  },
                  children: [
                    {
                      name: 'ns1:searchValue',
                      value: fromDate.toISOString(),
                      attributes: {
                        'xsi:type': 'xsd:dateTime',
                        'xmlns:ns1': this.buildUrnCore(),
                      },
                    },
                    {
                      name: 'ns1:searchValue2',
                      value: toDate.toISOString(),
                      attributes: {
                        'xsi:type': 'xsd:dateTime',
                        'xmlns:ns1': this.buildUrnCore(),
                      },
                    },
                  ],
                },
                {
                  name: 'ns1:status',
                  attributes: {
                    operator: 'anyOf',
                    'xmlns:ns1': this.buildUrnCommon(),
                  },
                  children: [
                    {
                      name: 'ns1:searchValue',
                      value: status,
                      attributes: {
                        'xsi:type': 'xsd:string',
                        'xmlns:ns1': this.buildUrnCore(),
                      },
                    },
                  ],
                },
                {
                  name: 'ns1:entity',
                  attributes: {
                    operator: 'anyOf',
                    'xmlns:ns1': this.buildUrnCommon(),
                  },
                  children: [
                    {
                      name: 'ns1:searchValue',
                      attributes: {
                        internalId: vendorId,
                        'xsi:type': 'ns1:RecordRef',
                        'xmlns:ns1': this.buildUrnCore(),
                      },
                    },
                  ],
                },
              ],
            },
          ],
        },
        {
          name: 'ns1:columns',
          children: [
            {
              name: 'ns1:basic',
              children: [
                {
                  name: 'internalId',
                  attributes: {
                    'xmlns:ns1': this.buildUrnCommon(),
                  },
                },
                {
                  name: 'tranDate',
                  attributes: {
                    'xmlns:ns1': this.buildUrnCommon(),
                  },
                },
                {
                  name: 'status',
                  attributes: {
                    'xmlns:ns1': this.buildUrnCommon(),
                  },
                },
              ],
            },
          ]
        },
      ],
    };
  }
  */

  /**
   * @private  This method is for internal use only
   */
  buildDateStatusVendorNeedsSyncSearchBody({
    recordType,
    fromDate,
    toDate,
    status,
    vendorId,
    vendorLocation,
    dropshipperOrderId,
    needsSync,
  }) {
    const searchBodyContainer = this.buildSearchBodyContainer();
    searchBodyContainer.children.push(this.buildRecordTypeBodyItem(recordType));
    if (fromDate && toDate) {
      searchBodyContainer.children.push(this.buildTransactionDateRangeBodyItem({ fromDate, toDate }));
    }
    if (status) {
      searchBodyContainer.children.push(this.buildStatusBodyItem(status));
    }
    if (vendorId) {
      searchBodyContainer.children.push(this.buildVendorIdBodyItem(vendorId));
    }
    if (vendorLocation) {
      searchBodyContainer.children.push(this.buildVendorLocationBodyItem(vendorLocation));
    }
    let customFieldListContainer;
    if (dropshipperOrderId !== undefined || needsSync !== undefined) {
      customFieldListContainer = this.buildCustomFieldListContainerBodyItem();
      if (dropshipperOrderId !== undefined) {
        customFieldListContainer.children.push(this.buildDropshipperOrderIdCustomFieldBodyItem(dropshipperOrderId));
      }
      if (needsSync !== undefined) {
        customFieldListContainer.children.push(this.buildNeedsSyncCustomFieldBodyItem(needsSync));
      }
    }
    if (customFieldListContainer) {
      searchBodyContainer.children.push(customFieldListContainer);
    }
    return searchBodyContainer;
  }

  /**
   * @private  This method is for internal use only
   */
  buildDateRangeStatusSearchBody({ recordType, fromDate, toDate, status }) {
    const searchBodyContainer = this.buildSearchBodyContainer();
    searchBodyContainer.children.push(this.buildRecordTypeBodyItem(recordType));
    searchBodyContainer.children.push(this.buildTransactionDateRangeBodyItem({ fromDate, toDate }));
    searchBodyContainer.children.push(this.buildStatusBodyItem(status));
    return searchBodyContainer;
  }

  /**
   * @private  This method is for internal use only
   */
  buildDateRangeSearchBody({ recordType, fromDate, toDate }) {
    const searchBodyContainer = this.buildSearchBodyContainer();
    searchBodyContainer.children.push(this.buildRecordTypeBodyItem(recordType));
    searchBodyContainer.children.push(this.buildTransactionDateRangeBodyItem({ fromDate, toDate }));
    return searchBodyContainer;
  }

  /**
   * @private  This method is for internal use only
   */
  buildCreatedFromSearchBody({ soInternalId, recordType }) {
    const searchBodyContainer = this.buildSearchBodyContainer();
    searchBodyContainer.children.push(this.buildCreatedFromBodyItem(soInternalId));
    searchBodyContainer.children.push(this.buildRecordTypeBodyItem(recordType));
    return searchBodyContainer;
  }

  // ---- Public methods

  async searchFolder(folderPath) {
    // Originally based on https://gitlab.com/twec/digital/netsuite-upload-utils/blob/master/src/file-cabinet-client.ts#L340
    const folderPathArray = folderPath.split(path.sep);
    debug(folderPath, folderPathArray);
    const body = this.buildSearchFolderBody();
    debug('Searching for folder', folderPathArray);
    const response = await this.makeSoapRequest('search', body);
    const { status, recordList } = response || {};
    NetSuiteClient.checkStatusSuccess(status);
    debug('response status:', status);
    const folderRecords = (recordList || {}).record || [];
    // debug(folderRecords);
    const folder = foldersUtils.findFolderRecord(folderPathArray, folderRecords);
    if (!folder) throw new Error('Folder not found');
    return folder;
  }

  async getFolderInternalId(targetFilePath) {
    const folderPath = path.dirname(targetFilePath);
    const folderRecord = await this.searchFolder(folderPath);
    debug(folderRecord);
    const folderInternalId = folderRecord['@internalId'];
    return folderInternalId;
  }

  async uploadFileContent(fileContent, targetFilePath) {
    const folderInternalId = await this.getFolderInternalId(targetFilePath);
    const filename = path.basename(targetFilePath);
    const body = this.buildUploadBody({
      filename,
      folderInternalId,
      fileContent,
    });
    const response = await this.makeSoapRequest('upsert', body);
    debug('Upload response:', response);
    const { status, baseRef } = response || {};
    NetSuiteClient.checkStatusSuccess(status);
    return baseRef;
  }

  // Upload a local file
  async uploadFile(localFilePath, targetFilePath) {
    debug('Upload', localFilePath, 'to', targetFilePath);
    const fileContent = await NetSuiteClient.readFileContent(localFilePath);
    return this.uploadFileContent(fileContent, targetFilePath);
  }

  /**
   * Find all of the NetSuite SalesOrder records within a given date range and status
   * @async
   * @param {Date} fromDate                    From date
   * @param {Date} toDate                      To date
   * @param {netSuiteSalesOrderStatus} status  OPTIONAL SalesOrder's status
   * @return {Promise<NetSuiteSalesOrder[]>}  Array of instances of the NetSuiteSalesOrder class
   */
  async searchForSalesOrders({
    fromDate,
    toDate,
    status, // optional
  }) {
    let body = null;
    if (status !== undefined) {
      body = this.buildDateRangeStatusSearchBody({
        recordType: 'salesOrder',
        fromDate,
        toDate,
        status,
      });
    } else {
      body = this.buildDateRangeSearchBody({
        recordType: 'salesOrder',
        fromDate,
        toDate,
      });
    }
    const response = await this.makeSoapRequest('search', body);
    const { responseStatus, totalRecords, recordList } = response || {};
    NetSuiteClient.checkStatusSuccess(responseStatus);
    debug('response status:', responseStatus);
    if (totalRecords === 0) return [];
    const netsuiteSalesOrders = [];
    const records = recordList.record.length !== undefined ? recordList.record : [recordList.record];
    records.forEach(netsuiteInternalSalesOrderRecord => {
      const netsuiteSalesOrder = new NetSuiteSalesOrder(netsuiteInternalSalesOrderRecord);
      netsuiteSalesOrders.push(netsuiteSalesOrder);
    });
    return netsuiteSalesOrders;
  }

  /**
   * Get a NetSuite SalesOrder record given its internal Id or external Id
   * @async
   * @param {object} props
   * @param {string} props.internalId  NetSuite internal Id
   * @param {string} props.externalId  NetSuite external Id
   * @return {Promise<NetSuiteSalesOrder>}  Instance of the NetSuiteSalesOrder class
   */
  async getSalesOrder({ internalId, externalId }) {
    const netsuiteInternalSalesOrderRecord = await this.getRecord({
      type: 'salesOrder',
      internalId,
      externalId,
    });
    return new NetSuiteSalesOrder(netsuiteInternalSalesOrderRecord);
  }

  /**
   * Update a NetSuite SalesOrder given its internal Id or extenal Id
   * @async
   * @param {object}         props
   * @param {string}         props.internalId    NetSuite internal Id
   * @param {string}         props.externalId    NetSuite external Id
   * @param {UpdateValues[]} props.updateValues  Values to be updated in the SalesOrder
   * @param {string[]}       props.nullFields    Values to be cleared in the SalesOrder
   * @return {Promise<boolean>}  true if the operation succeeds, else returns false
   */
  async updateSalesOrder({ internalId, externalId, updateValues, nullFields }) {
    const netsuiteUpdateSalesOrder = await this.updateRecord({
      type: 'SalesOrder',
      fieldDefinitionType: 'tranSales',
      internalId,
      externalId,
      updateValues,
      nullFields,
    });
    debug('Update Sales Order Response : %s', netsuiteUpdateSalesOrder);
    return netsuiteUpdateSalesOrder;
  }

  /**
   * Find all of the NetSuite PurchaseOrder records given a SalesOrder's internal Id
   * @async
   * @param {string} soInternalId                 NetSuite SalesOrder internal Id
   * @return {Promise<NetSuitePurchaseOrder[]>}   Array of instances of the NetSuitePurchaseOrder class
   *  or...
   * @param {Date} fromDate                       OPTIONAL From date
   * @param {Date} toDate                         OPTIONAL To date
   * @param {netSuitePurchaseOrderStatus} status  OPTIONAL Enum: PurchaseOrder's status
   * @param {string} vendorId                     OPTIONAL Vendor's Id
   * @param {string} vendorLocation               OPTIONAL Vendor's location
   * @param {string} dropshipperOrderId           OPTIONAL Dropshippers's Order Id
   * @param {boolean} needsSync                   OPTIONAL Needs Sync flag
   * @param {boolean} returnClientClasses         OPTIONAL Return client classes to the caller flag
   * @return {Promise<NetSuitePurchaseOrder[]>}   Array of NetSuite PurchaseOrder JSON objects
   */
  async searchForPurchaseOrders({
    soInternalId,
    fromDate,
    toDate,
    status,
    vendorId,
    vendorLocation,
    dropshipperOrderId,
    needsSync,
    returnClientClasses,
  }) {
    let body = null;
    if (soInternalId !== undefined) {
      body = this.buildCreatedFromSearchBody({
        soInternalId,
        recordType: 'purchaseOrder',
      });
    } else {
      body = this.buildDateStatusVendorNeedsSyncSearchBody({
        recordType: 'purchaseOrder',
        fromDate,
        toDate,
        status,
        vendorId,
        vendorLocation,
        dropshipperOrderId,
        needsSync,
      });
    }
    const response = await this.makeSoapRequest('search', body);
    const { totalRecords, recordList } = response || {};
    const responseStatus = response.status;
    NetSuiteClient.checkStatusSuccess(responseStatus);
    debug('response status:', responseStatus);
    if (totalRecords === 0) return [];
    const records = recordList.record.length !== undefined ? recordList.record : [recordList.record];
    if (!returnClientClasses || this.config.bodyFieldsOnly) {
      return records;
    }
    const netsuitePurchaseOrders = [];
    records.forEach(netsuiteInternalPurchaseOrderRecord => {
      const netsuitePurchaseOrder = new NetSuitePurchaseOrder(netsuiteInternalPurchaseOrderRecord);
      netsuitePurchaseOrders.push(netsuitePurchaseOrder);
    });
    return netsuitePurchaseOrders;
  }

  /**
   * Get a NetSuite PurchaseOrder record given its internal Id
   * @async
   * @param {string} internalId  NetSuite PurchaseOrder internal Id
   * @return {Promise<NetSuitePurchaseOrder>}  Instance of the NetSuitePurchaseOrder class
   */
  async getPurchaseOrder(internalId) {
    const netsuiteInternalPurchaseOrderRecord = await this.getRecord({
      type: 'purchaseOrder',
      internalId,
    });
    return new NetSuitePurchaseOrder(netsuiteInternalPurchaseOrderRecord);
  }

  /**
   * Update a NetSuite PurchaseOrder given its internal Id or extenal Id
   * @async
   * @param {object}         props
   * @param {string}         props.internalId    NetSuite internal Id
   * @param {string}         props.externalId    NetSuite external Id
   * @param {UpdateValues[]} props.updateValues  Values to be updated in the PurchaseOrder
   * @param {string[]}       props.nullFields    Values to be cleared in the PurchaseOrder
   * @return {Promise<boolean>}  true if the operation succeeds, else returns false
   */
  async updatePurchaseOrder({ internalId, externalId, updateValues, nullFields }) {
    const netsuiteUpdatePurchaseOrder = await this.updateRecord({
      type: 'PurchaseOrder',
      fieldDefinitionType: 'tranPurch',
      internalId,
      externalId,
      updateValues,
      nullFields,
    });
    debug('Update Purchase Order Response : %s', netsuiteUpdatePurchaseOrder);
    return netsuiteUpdatePurchaseOrder;
  }

  /**
   * Find all of the NetSuite ItemFulfillment records given a SalesOrder's internal Id
   * @async
   * @param {string} soInternalId  NetSuite SalesOrder internal Id
   * @return {Promise<NetSuiteItemFulfillment[]>}  Array of instances of the NetSuiteItemFulfillment class
   */
  async searchForItemFulfillments(soInternalId) {
    const body = this.buildCreatedFromSearchBody({
      soInternalId,
      recordType: 'itemFulfillment',
    });
    const response = await this.makeSoapRequest('search', body);
    const { status, totalRecords, recordList } = response || {};
    NetSuiteClient.checkStatusSuccess(status);
    debug('response status:', status);
    if (totalRecords === 0) return [];
    const netsuiteItemFulfillments = [];
    const records = recordList.record.length !== undefined ? recordList.record : [recordList.record];
    records.forEach(netsuiteInternalItemFulfillmentRecord => {
      const netsuiteItemFulfillment = new NetSuiteItemFulfillment(netsuiteInternalItemFulfillmentRecord);
      netsuiteItemFulfillments.push(netsuiteItemFulfillment);
    });
    return netsuiteItemFulfillments;
  }

  /**
   * Get a NetSuite ItemFulfillment record given its internal Id
   * @async
   * @param {string} internalId  NetSuite ItemFulfillment internal Id
   * @return {Promise<NetSuiteItemFulfillment>}  Instance of the NetSuiteItemFulfillment class
   */
  async getItemFulfillment(internalId) {
    const netsuiteInternalItemFulfillmentRecord = await this.getRecord({
      type: 'itemFulfillment',
      internalId,
    });
    return new NetSuiteItemFulfillment(netsuiteInternalItemFulfillmentRecord);
  }

  /**
   * Find all of the NetSuite CashSale records given a SalesOrder's internal Id
   * @async
   * @param {string} soInternalId  NetSuite SalesOrder internal Id
   * @return {Promise<NetSuiteCashSale[]>}  Array of instances of the NetSuiteCashSale class
   */
  async searchForCashSales(soInternalId) {
    const body = this.buildCreatedFromSearchBody({
      soInternalId,
      recordType: 'cashSale',
    });
    const response = await this.makeSoapRequest('search', body);
    const { status, totalRecords, recordList } = response || {};
    NetSuiteClient.checkStatusSuccess(status);
    debug('response status:', status);
    if (totalRecords === 0) return [];
    const netsuiteCashSales = [];
    const records = recordList.record.length !== undefined ? recordList.record : [recordList.record];
    records.forEach(netsuiteInternalCashSaleRecord => {
      const netsuiteCashSale = new NetSuiteCashSale(netsuiteInternalCashSaleRecord);
      netsuiteCashSales.push(netsuiteCashSale);
    });
    return netsuiteCashSales;
  }

  /**
   * Get a NetSuite CashSale record given its internal Id
   * @async
   * @param {string} internalId  NetSuite CashSale internal Id
   * @return {Promise<NetSuiteCashSale>}  Instance of the NetSuiteCashSale class
   */
  async getCashSale(internalId) {
    const netsuiteInternalCashSaleRecord = await this.getRecord({
      type: 'cashSale',
      internalId,
    });
    return new NetSuiteCashSale(netsuiteInternalCashSaleRecord);
  }
}

module.exports = {
  NetSuiteClient,
  netSuitePurchaseOrderStatus,
};
